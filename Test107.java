/*===========================
   ■■■ 클래스 고급 ■■■
   - 상속(Inheritance)
 ============================*/

 /*
 ○ 상속(Inheritance) 이란
	새로 설계(생성)하고자 하는 클래스가
	이미 설계되어 있는 다른 클래스의 기능과 중복되는 경우
	이미 설계된 클래스의 일부분이나 전체 구조를 공유할 수 있도록 하는 기능을 의미한다.

	즉, 상속은 객체를 좀 더 쉽게 만들 수 있는
	고수준의 재사용성(reusability)을 확보하고
	객체간의 관계를 구성함으로써
	객체 지향의 또 다른 큰 특징인 『다형성』의 문법적 토대가 된다.

	상속은 기존 프로그램의 클래스 내용을 공유함으로써
	중복된 코드들을 재작성할 필요 없이
	반복적이고 세부적인 작업을 처리하지 않기 때문에
	프로그램을 작성하는 시간을 절약할 수 있고
	유지보수를 편리하게 할 수 있으며,
	프로그램의 길이도 짧아지게 된다.

	또한, 이미 작성된 프로그램들은 앞서 테스트되었기 때문에
	오류를 줄일 수 있어 현재 작성중인 프로그램에만 전념할 수 있다.

※ 주의할 점
	자바는 다.중.상.속.을 지원하지 않기 때문에
	두 개 이상의 클래스로부터 상속받을 수 없다.

상위 클래스 == 부모 클래스 == 조상 클래스 == Super 클래스  → 물려주는 클래스
하위 클래스 == 자식 클래스 == 자손 클래스 == Sub 클래스    → 물려받는 클래스 (대상 결정)


 ※ 『super』

 	static 으로 선언되지 않은 메소드에서 사용되며
	현재 클래스가 상속받은 상위 클래스의 객체를 가리킨다.
	super 는 상위 클래스의 생성자를 호출하거나,
	상위 클래스의 멤버 변수 또는 메소드를 호출할 때 사용할 수 있다.

	하위 클래스의 생성자에서 상위 클래스의 생성자를 호출할 때에는
	하위 클래스의 생성자 정의 구문에서 맨 처음에만 위치할 수 있다.
	(이건.. 상속의 문법이 아니라... 앞에서 공부한 생성자의 기본적인 문법~!!!)

 */

//@ 같은 패키지에 있는 다른 클래스 2개(남남이지만 우연히 같은 패키지에 살고 있네~!)
//@ 내 물리적인 경로에 여기 이걸 넣어놨다~ 를 개념적, 논리적 정보로 저장하고 확인하게 정리하는게 패키지!
//@ 별도로 패키지 제작 X시, 기본으로 디폴트 패키지안에 들어 있음

//@ 책으로 나중에 공부하려고하면 어려울거..! 딴생각 하지말고 귀 기울이면 어떤책에 나와있는 내용보다 쉽게 접근할거~!

// 부모 클래스
class SuperTest107
{
	protected double area;
	
	// 부모 클래스의 생성자
	SuperTest107()
	{
		System.out.println("Super class...");
	}

	void write(String title)
	{
		System.out.println(title + " - " + area);
	}
	
}

// 자식 클래스(@ 야 이거 왜이래 우리 부모가 SuperTest107이야~!)
// ※ 자바는 단일 상속만 지원되며, 다중 상속은 허용되지 않는다.

public class Test107 extends SuperTest107//, SuperTest108, SuperTest109(@ 이건 다중 상속)
{
	/*(상속 → 이렇게 복붙했다고 생각하면 됨)
	protected double area;
	
	//@ 이때 부모클래스의 생성자는 제외
	//@ But
	//@ 이 메모리 퍼올리면서 변수 초기화해야하는 의무도 존재


	//SuperTest107()
	//{
	//	System.out.println("Super class...");
	//}


		void write(String title)
		{
			System.out.println(title + "-" + area);
		}
	*/
	
	//double area = 10.1234;


	// 자식 클래스의 생성자
	//@ 메모리할당, 변수 초기화..
	//@ 부모클래스 생성 구문 포함되어 있음
	Test107()
	{	
		// 부모 클래스 생성자 호출(@가장 먼저 삽입되어 있겠다.. 클래스 생성자 내부에서 다른 클래스 생성자 호출 가능한데 
		//							근데 제일먼저 실행되는 위치에서 호출해야 함)
		// SuperTest107();	//	this(); → Test107(); X (@내가 나를 호출하는게 되어버림 이렇게쓰면 안됨) ==> super → SuperTest107
		// super(); //@ ★주의~!!! 여기 이해하고 넘어가야 추상클래스..인터페이스..계보 족보....등등 이해가능(스킬포인트 꽝!)

		System.out.println("Sub class...");
		// super();
		//--==>> 에러 발생(컴파일 에러)

	}
	
	public void circle()
	{
		int r = 10;
		area = r * r * 3.141592;
		write("원");
	}
	
	public void rect() //@ rect 메소드
	{
		int w=20, h=5;
		super.area = w * h;
		//-- SuperTest107.area = w * h;
		super.write("사각형");
		//-- SuperTest107.write("사각형");
	}
	

	public static void main(String[] args)
	{
		// Test107 클래스(자식) 기반 인스턴스 생성
		//           @ 생성자 호출 - 이 과정에서 부모 권리뿐 아니라 책임도 물려받음....
		Test107 ob = new Test107();

		ob.circle();
		//--==>> 원 - 314.1592
		ob.rect();
		//--==>> 사각형 - 100.0

	}
}

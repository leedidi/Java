/*===========================
   ■■■ 클래스 고급 ■■■
   - 상속(Inheritance)
 ============================*/

// ※ 생성자와 클래스 상속간의 관계
//
//	  하위 클래스는 상위 클래스의 멤버를 상속받지만,
//    생성자는 상속 대상에서 제외된다.
//	  그리고, 하위 클래스의 생성자가 호출될 때
//    자동으로 상위 클래스의 생성자가 호출된다.
//    이 때, 호출되는 상위 클래스의 생성자는
//    인수가 없는 생성자(default 생성자 형태)가 된다.

//    상위 클래스 및 하위 클래스를 설계하는 과정에서
//    상위 클래스의 생성자를 정의하지(작성하지) 않거나
//    인수가 없는 생성자만을 정의한(작성한) 경우
//    명시적으로 하위 클래스에서 상위 클래스의 생성자를 호출하지 않아도
//    아무런 문제가 발생하지 않지만
//    상위 클래스에 인자가 있는 생성자만 존재하는 경우에는
//    주의해야 한다.

//    예를 들어... 다음에서...
/*
	class A_class
	{
		A_class(int n)
		{
		}
	}

	class B_class extends A_class
	{
		B_class()
		{
			// super();
		}
	}
*/
//	   하위 클래스인 B_class 의 생성자에서
//	   명시적으로 A_class 의 생성자를 호출하지 않으면
//	   자동으로 인자 없는 생성자를 호출한다.
//	   하지만, A_class 에는 인자가 있는 생성자만 존재하고
//     인자가 없는 생성자는 존재하지 않기 때문에 에러 발생한다.
//     따라서, B_class 생성자의 선두에
//     다음처럼 명시적으로 상위 클래스의 생성자 호출 구문을
//     작성해야 한다.
/*
	class A_class
	{
		A_class(int n)
		{
		}
	}

	class B_class extends A_class
	{
		B_class()
		{
			super(10);
			...
			...
		}
	}
*/

//@ 컨트롤키 누르고 방향키 누르면 키보드 고정된 채로 화면 위아래로 움직임!
/*
=========================================================================================================================
  상위 클래스    |  하위 클래스       |  결과
-------------------------------------------------------------------------------------------------------------------------
 생성자를        | 생성자 정의 안함   | → 가능하다.
 정의하지	     | 인수가 없는 생성자 | → 가능하다.
 않음			 | 인수가 있는 생성자 | → 가능하다.
-------------------------------------------------------------------------------------------------------------------------
 인수가          | 생성자 정의 안함   | → 가능하다.
 없는		     | 인수가 없는 생성자 | → 가능하다.
 생성자만 정의   | 인수가 있는 생성자 | → 가능하다.
-------------------------------------------------------------------------------------------------------------------------
 인수가          | 생성자 정의 안함   | → 에러 발생. //@디폴트 자동삽입
 있는            | 인수가 없는 생성자 | → 상위 클래스의 해당 생성자를 호출하지 않으면 에러 발생 //@호출구문 생성해 줘야 함
 생성자만 정의   | 인수가 있는 생성자 | → 상위 클래스의 해당 생성자를 호출하지 않으면 에러 발생
=========================================================================================================================
*/


// Rect108 클래스와 Circle108 클래스의 부모 클래스
 class SuperTest108
 {
	 protected double area; //@ 대부분 private 사용.. protected 사용한다면 상속 염두에 둔거라고 생각해도 됨
	 private String title;	//@ private -> 접근조차 못하고, 상속을 받지 못한다....라고 이해하기
	                        //@ 부모님이 혼자만 비밀금고에 일기장 넣어놓고 혼자 보고 계신데 이거 상속할수 X
							//@ 접근 못하겠지만 상속해줄게~ 이건 놀리는거 ㅋㅋ
	
	 // 부모 클래스의 인자 없는 사용자 정의 생성자
	 public SuperTest108()
	 {
		 System.out.println("SuperTest108... 인자 없는 생성자");
	 }

	 // 부모 클래스의 문자열을 인자로 받는 사용자 정의 생성자
	 public SuperTest108(String title)
	 {
		 this.title = title;
		 System.out.println("SuperTest108... 문자열을 인자로 받는 생성자");
	 }

	 public void write()
	 {
		 System.out.println(title + " - " + area);
	 }

 }

// SuperTest108 클래스를 상속받는 자식 클래스
 class Rect108 extends SuperTest108
 {	
	 // 상속받은 것들
	 /*
	protected double area; 

	 public void write()
	 {
		 System.out.println(title + " - " + area);
	 }
	*/

	 private int w, h;

	// 자식 클래스의 인자 없는 사용자 정의 생성자
	 public Rect108()
	 {
		 // 자동으로 삽입
		 //super();	/@포함된 클래스 -> 누구를 상속받나 보기 -> → SuperTest108();
	 }

	 public void calc(int w, int h)
	 {
		 this.w = w;
		 this.h = h;
		 area = (double)this.w * this.h;
		 // super.area = (double)this.w * this.h; // 가능(물려받은 에어리어)
		 // this.area = (double)this.w * this.h;  // 가능(내가 가진 에어리어)(부모님으로부터 검정 세단.캐딜락(차) 물려받음. 
												  //@ 내가 가진 캐딜락 = 부모님으로부터 물려받은 캐딜락
												  
												  //@ 그냥 캐딜락 =>=> 내가 내돈주고 산 캐딜락
												  //@ ◈선택 가능!
		 write();
	 }
	
	//실수한게 아니라 일부러 튜닝한거야~!
	 @Override			//-- 어노테이션(annotation) - metadata - JDK 1.5
						//@ "@Override" 이거 써도되고 안써도되고 x. 써줘야 함!
	 public void write()
	 {
		 System.out.println("w : " + w + ", h : " + h);
		 System.out.println("사각형 - " + area);
	 }
	 //@ ◈선택X, 이거 하는 순간 덮어씌워짐! 
	 //@ 부모님께 물려받은 캐딜락.. 받자마자 스포츠카로 뜯어고쳐서 개조함
	 //@ 원래 검정색 캐딜락 물려받았지만 노란색 스포츠카로 개조. 이제는 이전의 검정 캐딜락은 없음
	 //@ 더이상 상속받은거, 해당으로 돌아갈수 없음~!!!

	 // ※ 메소드 오버라이딩(Method Overriding)
	 //    상위 클래스(부모 클래스)를 상속받은 하위 클래스(자식 클래스)에서
	 //    상위 클래스에 정의된 메소드를 다시 정의하는 것으로(재정의)
	 //    객체 지향 프로그래밍의 특징인 다형성을 나타낸다.
	 //    재정의(Overriding)는 반드시 상속 관계에 있어야 하며,
	 //    메소드의 이름, 리턴 타입, 매개변수의 갯수나 타입이
	 //    완전히 일치해야 한다.
	 //@  (메소드 오버로딩과 구별, 오버라이딩은 상속에서만 존재!)
 }

// SuperTest108 클래스를 상속받는 자식 클래스 
class Circle108 extends SuperTest108
{	
	// 상속받은 것들
	/*
	protected double area; 

	 public void write()
	 {
		 System.out.println(title + " - " + area);
	 }
	*/
	
	/* default 생성자 → 아래의 사용자 정의 생성자가 있기 때문에 자동으로 삽입되지 않는다.
	public Circle108()
	{
	}
	*/

	// 자식 클래스의 문자열을 인자로 받는 사용자 정의 생성자
	public Circle108(String title)
	{	
		// super();   //@ 이게 자동으로 삽입됨 //--==>> SuperTest108... 인자 없는 생성자
		super(title); //@ 인자있는 생성자 삽입하고 싶다면 이거 쓰기 //--==>> SuperTest108... 문자열을 인자로 받는 생성자
	}
	//@@@ 문자열을 인자로 받는 사용자 정의 생성자에서도 super(); 디폴트로 삽입 되나,,,? 안되나,,,? 안되는거 같음,,! 아 되는거같기도,,
	//@@@ defalt 생성자는 public Circle108() ~ super(); 이거 얘기하는 건가 싶기도 함

	public void calc(int r)
	{
		area = r * r * 3.141592;
		write();		//@ 부모로부터 물려받은 write! 튜닝한건 첫째 사정.... 둘째는 그대로 사용중이라 가능!
	}
}

// main() 메소드를 포함하고 있는 외부의 다른 클래스
public class Test108
{
	public static void main(String[] args)
	{
		Rect108 ob1 = new Rect108(); //@ 자식클래스 기반 인스턴스 생성
		//--==>> SuperTest108... 인자 없는 생성자

		//Circle108 ob2 = new Circle108();
		//--==>> 에러 발생(컴파일 에러)
		//-- 현재 Circle108 클래스에는
		//   매개변수를 필요로 하는 사용자 정의 생성자가 만들어져 있으며
		//   이로 인해 default 생성자가 자동으로 삽입되지 않는 상황.

		Circle108 ob = new Circle108("원"); // 
		//--==>> SuperTest108... 인자 없는 생성자
		//--==>> SuperTest108... 문자열을 인자로 받는 생성자
	}
	
}